From 632e9f950f6b1619f1cbe4c32ff50386cb48a4ba Mon Sep 17 00:00:00 2001
From: Bram Oosterhuis <dev@bybram.com>
Date: Fri, 13 Jun 2025 16:03:00 +0200
Subject: [PATCH] Add pkg-config support and enhance session management

- Introduced pkg-config file generation for libdropbear.
- Added client IP and timestamp tracking in session management.
- Updated header files to declare new functions for server activation and session info retrieval.
---
 Makefile.in       |  38 +++++++
 chansession.h     |   2 +
 libdropbear.c     | 247 ++++++++++++++++++++++++++++++++++++++++++++++
 libdropbear.h     |  45 +++++++++
 libdropbear.pc.in |  11 +++
 svr-chansession.c |   8 +-
 6 files changed, 350 insertions(+), 1 deletion(-)
 create mode 100644 libdropbear.c
 create mode 100644 libdropbear.h
 create mode 100644 libdropbear.pc.in

diff --git a/Makefile.in b/Makefile.in
index e824491..7ca301b 100644
--- a/Makefile.in
+++ b/Makefile.in
@@ -326,3 +326,41 @@ fuzz-hostkeys:
 
 fuzz-clean:
 	-rm -f fuzz/*.o $(FUZZ_TARGETS) $(FUZZER_OPTIONS)
+
+libdir=@libdir@
+includedir=@includedir@
+
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = libdropbear.pc
+
+VERSION := $(shell grep '^#define DROPBEAR_VERSION' sysoptions.h | sed 's/.*"\(.*\)"/\1/')
+
+libdropbear.pc: libdropbear.pc.in
+	@echo "Generating pkg-config file for libdropbear"
+	@sed \
+		-e 's,@prefix\@,$(prefix),g' \
+		-e 's,@exec_prefix\@,$(exec_prefix),g' \
+		-e 's,@libdir\@,$(libdir),g' \
+		-e 's,@includedir\@,$(includedir),g' \
+		-e 's,@PACKAGE_VERSION\@,$(VERSION),g' \
+		-e 's,@LIBS\@,$(LIBS),g' \
+		$< > $@
+	@echo "Done generating libdropbear.pc"
+
+inst_libdropbear.pc: libdropbear.pc
+	@echo "Installing pkg-config file to $(DESTDIR)$(pkgconfigdir)"
+	$(INSTALL) -d $(DESTDIR)$(pkgconfigdir)
+	$(INSTALL) -m 644 libdropbear.pc $(DESTDIR)$(pkgconfigdir)
+
+dropbearlibobjs = $(filter-out svr-main.o cli-main.o,$(dropbearobjs)) libdropbear.o
+
+libdropbear.a: $(dropbearlibobjs) $(HEADERS) $(LIBTOM_DEPS) Makefile
+	@echo "Building static library libdropbear.a"
+	$(AR) rcs $@ $(dropbearlibobjs)
+
+inst_libdropbear.a: libdropbear.a inst_libdropbear.pc
+	@echo "Installing libdropbear.a and headers"
+	$(INSTALL) -d $(DESTDIR)$(libdir)
+	$(INSTALL) -m 644 libdropbear.a $(DESTDIR)$(libdir)
+	$(INSTALL) -d $(DESTDIR)$(includedir)/dropbear
+	$(INSTALL) -m 644 $(srcdir)/*.h $(DESTDIR)$(includedir)/dropbear
diff --git a/chansession.h b/chansession.h
index cf4fba3..686df07 100644
--- a/chansession.h
+++ b/chansession.h
@@ -80,6 +80,8 @@ struct ChanSess {
 struct ChildPid {
 	pid_t pid;
 	struct ChanSess * chansess;
+    char ipstring[64];
+    char timestring[32];
 };
 
 
diff --git a/libdropbear.c b/libdropbear.c
new file mode 100644
index 0000000..796a1c7
--- /dev/null
+++ b/libdropbear.c
@@ -0,0 +1,247 @@
+#include "includes.h"
+#include "libdropbear.h"
+#include "session.h"
+#include "dbutil.h"
+#include "packet.h"
+#include "buffer.h"
+#include "auth.h"
+#include "runopts.h"
+
+#include "signkey.h"
+#include "dbrandom.h"
+#include "crypto_desc.h"
+#include <pthread.h>
+
+static pthread_t dropbear_thread;
+
+static int dropbear_running = 0;
+
+/* catch + reap zombie children */
+static void sigchld_handler(int UNUSED(unused))
+{
+    struct sigaction sa_chld;
+
+    const int saved_errno = errno;
+
+    while (waitpid(-1, NULL, WNOHANG) > 0) { }
+
+    sa_chld.sa_handler = sigchld_handler;
+    sa_chld.sa_flags = SA_NOCLDSTOP;
+    sigemptyset(&sa_chld.sa_mask);
+    if (sigaction(SIGCHLD, &sa_chld, NULL) < 0) {
+        dropbear_exit("signal() error");
+    }
+    errno = saved_errno;
+}
+
+/* catch any segvs */
+static void sigsegv_handler(int UNUSED(unused))
+{
+    fprintf(stderr, "Aiee, segfault! You should probably report "
+                    "this as a bug to the developer\n");
+    _exit(EXIT_FAILURE);
+}
+
+/* catch ctrl-c or sigterm */
+static void sigintterm_handler(int UNUSED(unused))
+{
+
+    ses.exitflag = 1;
+}
+
+/* Things used by inetd and non-inetd modes */
+static void commonsetup()
+{
+
+    struct sigaction sa_chld;
+#ifndef DISABLE_SYSLOG
+    if (opts.usingsyslog) {
+        startsyslog(PROGNAME);
+    }
+#endif
+
+    /* set up cleanup handler */
+    if (signal(SIGINT, sigintterm_handler) == SIG_ERR ||
+#ifndef DEBUG_VALGRIND
+        signal(SIGTERM, sigintterm_handler) == SIG_ERR ||
+#endif
+        signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
+        dropbear_exit("signal() error");
+    }
+
+    /* catch and reap zombie children */
+    sa_chld.sa_handler = sigchld_handler;
+    sa_chld.sa_flags = SA_NOCLDSTOP;
+    sigemptyset(&sa_chld.sa_mask);
+    if (sigaction(SIGCHLD, &sa_chld, NULL) < 0) {
+        dropbear_exit("signal() error");
+    }
+    if (signal(SIGSEGV, sigsegv_handler) == SIG_ERR) {
+        dropbear_exit("signal() error");
+    }
+
+    crypto_init();
+
+    /* Now we can setup the hostkeys - needs to be after logging is on,
+     * otherwise we might end up blatting error messages to the socket */
+    load_all_hostkeys();
+}
+
+static void main_inetd()
+{
+    char *host, *port = NULL;
+
+    /* Set up handlers, syslog */
+    commonsetup();
+
+    seedrandom();
+
+    if (svr_opts.reexec_childpipe < 0) {
+        /* In case our inetd was lax in logging source addresses */
+        get_socket_address(0, NULL, NULL, &host, &port, 0);
+        dropbear_log(LOG_INFO, "Child connection from %s:%s", host, port);
+        m_free(host);
+        m_free(port);
+
+        /* Don't check the return value - it may just fail since inetd has
+         * already done setsid() after forking (xinetd on Darwin appears to do
+         * this */
+        setsid();
+    }
+
+    /* -1 for childpipe in the inetd case is discarded */
+    svr_session(0, svr_opts.reexec_childpipe);
+
+    /* notreached */
+}
+
+// The thread function that runs the server
+static void* dropbear_server_thread(void* arg)
+{
+    _dropbear_exit = svr_dropbear_exit;
+    _dropbear_log = svr_dropbear_log;
+
+    disallow_core();
+    
+    main_inetd();
+    return NULL;
+}
+
+int parse_commandline(const char* cmdline)
+{
+    /* Convert cmdline string to argc/argv */
+    char* buf = strdup(cmdline);
+    int argc = 1; // Start at 1 for program name
+    char* p = buf;
+    char** argv = NULL;
+
+    // Count arguments
+    while (*p) {
+        while (*p && isspace(*p))
+            p++;
+        if (*p) {
+            argc++;
+            while (*p && !isspace(*p))
+                p++;
+        }
+    }
+
+    // Create argv array
+    argv = (char**)malloc(sizeof(char*) * (argc + 1));
+    argv[0] = "dropbear"; // Program name
+    int i = 1;
+    p = buf;
+
+    // Split into arguments
+    while (*p) {
+        while (*p && isspace(*p))
+            *p++ = '\0';
+        if (*p) {
+            argv[i++] = p;
+            while (*p && !isspace(*p))
+                p++;
+        }
+    }
+    argv[i] = NULL;
+
+    /* get commandline options */
+    svr_getopts(argc, argv);
+
+    /* cleanup */
+    free(argv);
+    free(buf);
+
+    return argc;
+}
+
+int activate_dropbear(const char* cmdline)
+{
+    if (dropbear_running)
+        return -1;
+
+    if (parse_commandline(cmdline) < 1) {
+        dropbear_exit("Bad cmdline");
+    }
+
+    // Start server in a new thread
+    if (pthread_create(&dropbear_thread, NULL, dropbear_server_thread, NULL) != 0) {
+        dropbear_exit("Failed to create Dropbear server thread");
+        return -1;
+    }
+
+    dropbear_running = 1;
+    return 0;
+}
+
+int deactivate_dropbear(void)
+{
+    if (!dropbear_running)
+        return -1;
+
+    // Cleanup and shutdown
+    dropbear_close("Deactivating Dropbear SSH server");
+
+    // Wait for the server thread to finish
+    pthread_join(dropbear_thread, NULL);
+
+    dropbear_running = 0;
+    return 0;
+}
+
+int get_active_sessions_count(void)
+{
+    unsigned int i;
+    int count = 0;
+
+    for (i = 0; i < svr_ses.childpidsize; i++) {
+        if (svr_ses.childpids[i].pid != 0) {
+            count++;
+        }
+    }
+
+    return count;
+}
+
+int get_active_sessions_info(struct client_info* info, int count)
+{
+    unsigned int i;
+    int written = 0;
+
+    if (!info || count <= 0)
+        return -1;
+
+    for (i = 0; i < svr_ses.childpidsize && written < count; i++) {
+        if (svr_ses.childpids[i].pid != 0) {
+            info[written].pid = svr_ses.childpids[i].pid;
+            strncpy(info[written].ipaddress,
+                svr_ses.childpids[i].ipstring,
+                sizeof(info[written].ipaddress) - 1);
+            strncpy(info[written].timestamp,
+                svr_ses.childpids[i].timestring,
+                sizeof(info[written].timestamp) - 1);
+            written++;
+        }
+    }
+
+    return written;
+}
\ No newline at end of file
diff --git a/libdropbear.h b/libdropbear.h
new file mode 100644
index 0000000..ec25906
--- /dev/null
+++ b/libdropbear.h
@@ -0,0 +1,45 @@
+#ifndef LIBDROPBEAR_H
+#define LIBDROPBEAR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct client_info {
+    int pid;
+    char ipaddress[64];
+    char timestamp[32];
+};
+
+/**
+ * Initialize and start Dropbear SSH server
+ * @param cmdline Command line arguments
+ * @return 0 on success, non-zero on failure
+ */
+int activate_dropbear(const char* cmdline);
+
+/**
+ * Shutdown Dropbear SSH server
+ * @return 0 on success, non-zero on failure
+ */
+int deactivate_dropbear(void);
+
+/**
+ * Get count of active SSH sessions
+ * @return Number of active sessions
+ */
+int get_active_sessions_count(void);
+
+/**
+ * Get information about active sessions
+ * @param info Array of client_info structures to fill
+ * @param count Size of array
+ * @return Number of sessions written
+ */
+int get_active_sessions_info(struct client_info* info, int count);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* LIBDROPBEAR_H */
\ No newline at end of file
diff --git a/libdropbear.pc.in b/libdropbear.pc.in
new file mode 100644
index 0000000..2da35f7
--- /dev/null
+++ b/libdropbear.pc.in
@@ -0,0 +1,11 @@
+prefix=@prefix@
+exec_prefix=@exec_prefix@
+libdir=@libdir@
+includedir=@includedir@
+
+Name: libdropbear
+Description: Dropbear SSH Library
+Version: @PACKAGE_VERSION@
+Libs: -L${libdir} -ldropbear
+Libs.private: @LIBS@
+Cflags: -I${includedir}/dropbear
\ No newline at end of file
diff --git a/svr-chansession.c b/svr-chansession.c
index 656a968..571d69a 100644
--- a/svr-chansession.c
+++ b/svr-chansession.c
@@ -940,7 +940,13 @@ static void addchildpid(struct ChanSess *chansess, pid_t pid) {
 	TRACE(("addchildpid %d pid %d for chansess %p", i, pid, chansess))
 	svr_ses.childpids[i].pid = pid;
 	svr_ses.childpids[i].chansess = chansess;
-
+	// Add client IP and timestamp
+	strncpy(svr_ses.childpids[i].ipstring, svr_ses.addrstring, sizeof(svr_ses.childpids[i].ipstring) - 1);
+	time_t now = time(NULL);
+	strftime(svr_ses.childpids[i].timestring,
+		sizeof(svr_ses.childpids[i].timestring),
+		"%Y-%m-%d %H:%M:%S",
+		localtime(&now));
 }
 
 /* Clean up, drop to user privileges, set up the environment and execute
-- 
2.34.1

